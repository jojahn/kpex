= Comparing Functional Programming in Go with Elixir
Jonas Jahns <jonas.jahns@stud.th-rosenheim.de>
1.0, Dec 21, 2020, Asciidoctor 1.5 article template
:toc:
:icons: font
:quick-uri: https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/

== Introduction

// To bring order into the chaos of immense amount of programming languages

There is an immense amount of programming languages out there. Programming languages can be separated into different types based on how programms are developed. An example are object-oriented languages like Java. Other programming languages can be functional and procedural. 

[quote, https://elixir-lang.org]
____
Functional programming promotes a coding style that helps developers write code that is short, concise, and maintainable. For example, pattern matching allows developers to easily destructure data and access its contents
____

The main goal of the arcticle is to compare the concept of functional programming with Go and Elixir. The majority of programming languages share features of other types and are not of a single type. Functional, procedural and object-oriented programming can be done in Elixir and in Go.

=== Functional Programming

Functional Programming is defined by many concepts that differentiate it from other types. One key concept is that functions are first-class citizens. First-class citizens of a programming language are treated equally to primitive types like strings or numbers. Meaning a first-class citizen can be a return type, assigned to variables and passed as arguments to functions. A very helpful concept is annonymous functions that can be directly assigned to a variable without prior declaration. 

Functional programming also includes higher-order functions that can be called with a function as an argument.
// <Composition,Closure, Currying, unary functions>
// <Why unary?>
Unary functions are functions that only take one arugment. To implement functions with more arguments currying comes into play. Pure functional programming does not support loops, if-else or switch statements. Instead these types of languages use recursion.

// <What is lazy evaluation?>
// <Immutable vars>
// <Why are functional prog. lang. stateless? Vorteile>
// <What are side effects?>
Programming languages that only support some parts of functional programming or are not only functional are called pure.  

Examples for functional programming languages are F#, Haskell and Elixir. Functional programming languages have the effect of 
// <Functional Programming Languages Usescases>

=== What is Go?

Go is a multi-paradigm programming language. It allows object oriented, functional and procedural programming. Go was developed by Google employees in 2009 as open source. While the development of Go compilation times was a key feature. Go itself stems from a C++ background, sharing some similarities. 

[quote, https://golang.org]
____
Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
____

Go is more simple than C\++ since it has less keywords and ditched pointer arithmetic. Go shines as the programming language for the backbone of cloud native stack. It is used in the area of application programming for cloud and the web. Other areas of Go are network and distribiuted systems. Go is used in Webservers and cloud infrastructure. It was not developed as a UI language. But there still exist GTK/QT C++ bindings. Go can also be used in embedded devices using the compiler TinyGo which is optimized for microcontrollers.

.types.go
[source,go]
----
// Primitive Types
var boolean bool = false || true
var String string = "Hello, World!"
var integer int = 1
var integer8Bit int8
// ... to int64
var unsignedInteger uint
var unsignedInteger8Bit int8
// ... to uint64
var Byte byte
var Rune rune // unicode
var Float32 float32 = 1.0
var Float64 float64

// Arrays, Slices and Maps
var array [3]int = [3]int{1, 2, 3}
var slice []int = array[0:]
var Map map[string][]int = make(map[string][]int)
----

Go has common datatypes like . the type follows the name
// <Where does the type in Go go?>

=== What is Elixir?

In contrast to Go Elixir is also a multi. It was built on top of Erlang, an functional programming designed for telecommunication backends. Elixir therefore uses the Erlang VM. Erlang libraries can be used in Elixir. This was a key feature for the developers. Elixir is not pure functional since it has features like loops, switches and if-else statements. Even object-oriented programming is possible.

// <What is OTP, Erlang?>

[quote, https://elixir-lang.org]
____
Elixir is a dynamic, functional language designed for building scalable and maintainable applications.
____

Elixir has similar use cases to Go.
// <usecase differences>
Elixir can also be run on embedded hardware using Nerves which is an IoT platform. 

// <Area>
// <Nerves, embedded devices>
// <Fault tolerant, scaleable>

Elixir uses primitive types similar to Go but more simple by skipping on the size option of types. Additionally it also has atoms. A feature of prolog that was passed over Erlang to Elixir. Atoms are
//...

.types.ex
[source,elixir]
----
# Primitive Types
string = "Hello, World!"
string = "Hello, #{:world}"
bool = false || true
integer = 1
float = 1.0
atom = :atom

# List, Maps and Tuples
list = [1, 2, 3]
map = %{"hello" => "world"}
tuple = {:red, :green, :blue}
----

Unlike Go Elixir requires a seperate build tool and package manager. The build tool of Elixir is called mix and it formats, runs tests, compiles and runs compiled Elixir source code. 

== Functional Programming in Go

// <How to write functions in Go>

Here is a basic example of function in Go. This function takes two integers and returns the sum.

.currying.go (functions)
[source, go]
----
func multiply(a int, b int) int {
	return a * b
}

func multiplyC(a int) func(int) int {
	return func(b int) int {
		return a * b
	}
}

func main() {
	multiply(2, 2)
}
----

// <Explain function add>

.types.go (structs and interfaces)
[source, go]
----
type Greeter interface {
	Greet() string
}

type Greeting struct {
	Greeter
	Receiver string
	Message  string
}

func (g *Greeting) Greet() string {
	return fmt.Sprintf("Hello, %s\n%s",
		g.Receiver, g.Message)
}

func main() {
	greeting := Greeting{
		Receiver: "World",
		Message:  "Here is Go",
	}
	greeting.Greet()
}
----

// <How does Functional Programming with Go work?>
// <Properties, first-class citizens, side effects>
// <casing>

== Functional Programming in Elixir

Functions in Elixir can annonymous or inside a module. An example for an annonymous function in Elixir is given in <<_types_ex__functions_, types.ex>>.

.currying.ex
[source,elixir]
----
multiply = fn x, y -> x * y end
multiplyC = fn x ->
    fn y -> x * y end
end

multiply.(2, 2)
multiplyC.(2).(2)
----

Here the function add is defined as a annonymous function. Calling the function is quite unusual by the need of a dot before the argument list in brackets. Elixir doesn't use curly brackets for distinquishing scopes. Instead keywords are used. A very important quirk of Elixir is the absence of a return keyword. Every function annonymous and named return the last statement of the function. This is a big step and changes development concepts.

.types.ex (modules)
[source,elixir]
----
defmodule Greeter do
    @type receiver :: String
    @type message :: String

    @spec greet(receiver, message) :: String
    def greet(receiver, message) do
        combine_greeting(receiver, message)
    end

    # Private Function
    defp combine_greeting(receiver, message) do
        "Hello, #{receiver}!\n#{message}"
    end
end

Greeter.greet("World", "Here is Elixir")
----

// <modules>
Modules in Elixir are starting with a capital letter. 

// <casing>
// <private functions>
// <defstructs>
// < => vs -> vs |> >

== Comparison of Functional Programming

Although Go is not a pure functional language it has many features of functional programming languages. And thus it can be compared with a functional programming language like Elixir.

Since modern programming languages have features of many types like object orientation or functional programming, programming languages can more differentiated with orthogonal classifications. Just like Go that has C++ background Elixir builds on top of the language Erlang. Various orthogonal classifications are listed in the Table <<_orthogonal_classifications,Orthogonal Classifications>>. 

.Orthogonal Classifications
|===
| Go | Elixir

|Static Typed
|Dynamic Typed

|Compiled
|Compiled

|Parallel
|Sequential?

|Static Linked
|Dynamic Linked?

|Safe
|Safe

|Platform Dependent Assemblercode
|Platform Independent Bytecode
|===

Elixir in comparison to Go has dynamic types, meaning it will evaluate types at runtime. The Elixir 
Elixir and Go have different types and typing approaches. Elixir for example does not have strict types. Much like languages like coffeescript types in Elixir can be added through annotations or decorators. 

// <Interactive Shell IEX.bat, .ex vs .exs>
// <moduls, plugins, require, import>
// <named unused arguments in Exlixir but not in go>

=== Lambda Calculus

// <What is the lambda calculus?>
// <Connection to functional programming>

.lambda_calculus.go
[source,go]
----
func t(x Function) Function {
	return func(y Function) Function {
		return x
	}
}

func f(x Function) Function {
	return func(y Function) Function {
		return y
	}
}

func i(x Function) Function {
	return x
}
----

// <How is it implemented in Go?>

.lambda_calculus.ex
[source,elixir]
----
t = fn x ->
  fn _y -> x end
end

f = fn _x ->
  fn y -> y end
end

i = fn x -> x end
----

// <How is it implemented in Elixir?>

=== Example Application

// <Compare HTTP server code structure>
// <[Compare HTTP request responsetimes]>

== ASCII DOC EX

This is a paragraph with a *bold* word and an _italicized_ word.

.Image caption
image::image-file-name.png[I am the image alt text.]

This is another paragraph.footnote:[I am footnote text and will be displayed at the bottom of the article.]

.Unordered list title
* list item 1
** nested list item
*** nested nested list item 1
*** nested nested list item 2
* list item 2

This is a paragraph.

.Example block title
====
Content in an example block is subject to normal substitutions.
====

.Sidebar title
****
Sidebars contain aside text and are subject to normal substitutions.
****

[#id-for-listing-block]
.Listing block title
----
Content in a listing block is subject to verbatim substitutions.
Listing block content is commonly used to preserve code input.
----

.Table title
|===
|Column heading 1 |Column heading 2

|Column 1, row 1
|Column 2, row 1

|Column 1, row 2
|Column 2, row 2
|===

[quote, firstname lastname, movie title]
____
I am a block quote or a prose excerpt.
I am subject to normal substitutions.
____

[verse, firstname lastname, poem title and more]
____
I am a verse block.
  Indents and endlines are preserved in verse blocks.
____

TIP: There are five admonition labels: Tip, Note, Important, Caution and Warning.

// I am a comment and won't be rendered.

. ordered list item
.. nested ordered list item
. ordered list item

The text at the end of this sentence is cross referenced to <<_third_level_heading,the third level heading>>

This is a link to the https://asciidoctor.org/docs/user-manual/[Asciidoctor User Manual].
This is an attribute reference {quick-uri}[which links this text to the Asciidoctor Quick Reference Guide].